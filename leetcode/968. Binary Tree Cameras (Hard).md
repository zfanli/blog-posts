---
tags:
  - DP
  - Greedy
---

# 968. Binary Tree Cameras (Hard)

思路 1，贪心从下而上，这里能使用贪心算法是因为我们可以从叶子节点开始，给叶子节点的父节点安装摄像头，并一步步往上推出需要安装摄像头的最小数量。

解题思路的第一步是要推算一个节点能有多少种状态，这道题每个节点存在 3 种状态：

- `0`: 无摄像头覆盖
- `1`: 有摄像头覆盖
- `2`: 节点安装了摄像头

第二步是要处理父节点遇到子节点处于上面各种状态时应该如何应对，根据状态有三种应对，我们需要按照顺序处理，即在下面的判断已经排除了上面的判断条件：

- 左右子节点有一个无摄像头覆盖（`0`）：此时父节点必须安装摄像头，即返回 `2`
- 左右子节点有一个安装了摄像头（`2`）：由于已经判断子节点没有无覆盖的情况，此时父节点可以算有摄像头覆盖，返回 `1`
- 除了上述情况以外（左右子节点均为 `1`）：由于没有子节点安装摄像头，此时父节点只能是无摄像头覆盖，返回 `0`

第二步程序的思路已经明确了，但是有些特殊情况需要处理，所以第三步我们要找出特殊 case。这里有 2 个特殊情况需要考虑：

- 叶子节点的处理
  - 由于我们希望叶子节点的父节点安装摄像头，所以我们希望叶子节点返回无摄像头覆盖（`0`）
  - 已知叶子节点的左右子节点均为空
    - 根据第二步总结的思路，当左右节点均为有摄像头覆盖（`1`）时，父节点才能返回无摄像头覆盖（`0`）
    - 结论：对于空节点需要返回有摄像头覆盖（`1`）
- 对于 `root` 节点的处理
  - `root` 节点也存在左右子节点存在无摄像头覆盖（`0`）的情况，有可能需要安装摄像头，处理有 2 中思路：
    1. 父节点需要安装摄像头时必须返回 `2`，所以判断递归最后一次返回值为 2 时主动增加一次计数
    2. 或者，用一个 `dummy` 节点包装 `root` 节点，将对其的处理包括在递归过程中，我们不关注 `dummy` 节点的返回值，这样可以省去手动判断
  - 这里我们选择第二种做法

思路整理到这里，可以开始实现算法了，下面是 Python 代码例子。

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def minCameraCover(self, root: TreeNode) -> int:
        # 0: not covered
        # 1: covered
        # 2: has camera

        def dfs(node):
            if node is None:
                # Mark none as covered
                return 1
            left = dfs(node.left)
            right = dfs(node.right)

            if min(left, right) == 0:
                self.ans += 1
                return 2
            elif max(left, right) == 2:
                return 1
            else:
                return 0

        self.ans = 0
        # Wrap root with a dummy node to avoid special case of 0 at root.
        dfs(TreeNode(left=root))

        return self.ans
```
