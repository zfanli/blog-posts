---
tags:
  - Tree
  - Stack
  - DFS
  - Binary Tree
---

# 94. Binary Tree Inorder Traversal (Easy)

遍历树的方法通常有三种，分别是前序遍历 pre-order traversal、中序遍历 in-order traversal 和后序遍历 post-order traversal。这道题是中序遍历。

难度上来说，前序最简单，中序和后序遍历会复杂一点。

思路 1，递归

```python
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        ans = []

        def traverse(node):
            if node is None:
                return
            traverse(node.left)
            ans.append(node.val)
            traverse(node.right)

        traverse(root)
        return ans
```

思路 2，遍历

基于前序遍历的方案做的修改，可以解决问题，但是在空间复杂度上有优化余地，为了储存 stack 使用了额外的 2n 的空间。

```python
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        ans, stack = [], [root]

        while len(stack) > 0:
            node = stack.pop()
            if node is None:
                continue
            if type(node) == int:
                ans.append(node)
            else:
                stack.append(node.right)
                stack.append(node.val)
                stack.append(node.left)

        return ans
```

思路 3，遍历，优化版本

中序遍历要先遍历左节点，所以先抵达最左路径的最后一个节点，从这个节点开始回溯，重复检查左节点，本体和右节点的顺序。

这其实是思路 1 递归的扁平化处理，使用 stack 来替代递归过程。时间复杂度和空间复杂度均为 O(n)。

```python
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        ans, stack, curr = [], [], root

        while curr or len(stack) > 0:
            # find the leftmost node
            while curr:
                stack.append(curr)
                curr = curr.left
            curr = stack.pop()
            # record its value
            ans.append(curr.val)
            # start the next turn with its right node
            curr = curr.right

        return ans
```
